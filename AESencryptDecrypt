import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;


public class AESencryptDecrypt {
	
	private static final char[] sbox = {
	        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };

	private static final char[] sboxInv = {
	        0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	        0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	        0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	        0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	        0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	        0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	        0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	        0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	        0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	        0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	        0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	        0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	        0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	        0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	        0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	        0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
	};

	private static final char[] rcon = {
	        0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
	        0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
	        0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
	        0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
	        0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
	        0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
	        0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
	        0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
	        0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
	        0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
	        0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
	        0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
	        0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
	        0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
	        0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
	        0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb
	};
	
	public static char[] plain="winstongrenieris".toCharArray();
	
	public static char[] key="winstongrenieriswinstongrenieris".toCharArray();

	public static void main(String[] args) {
		System.out.println("Encrypting:\n");
		char[] expand = expandKey(key);
		printArr(plain);
		System.out.println("Encrypted:\n");
		char[] encrypted = aesMain(plain,expand);
		printArr(encrypted);
		System.out.println("Decrypted:\n");
		char[] expand2 = expandKey(key);
		char[] decrypted = aesMainInv(encrypted,expand2);
		printArr(decrypted);
	}
	
	//rotate left if n>0; right n<0
	private static char[] rotate(char[] in,int n){
		boolean dir=n>0;
		n= Math.abs(n);
		n=n%in.length;
		char[] temp= new char[n];
		if(dir){
			for(int i=0;i<n;i++){
				temp[i]=in[i];
			}
			for(int i=n;i<in.length;i++){
				in[i-n]=in[i];
			}
			for(int i=0;i<n;i++){
				in[i+in.length-n]=temp[i];
			}
		}else{
			for(int i=in.length-n;i<in.length;i++){
				temp[i-in.length+n]=in[i];
			}
			for(int i=in.length-1;i>=n;i--){
				in[i]=in[i-n];
			}
			for(int i=0;i<n;i++){
				in[i]=temp[i];
			}
		}
		return in;	
	}
	
	private static char[] shiftRows(char[] in, boolean encrypt){
		char[] t=new char[4];
		for(int i=0;i<4;i++){
			for(int j=0;j<4;j++){
				t[j]=in[j+i*4];
			}
			if(encrypt){
				t=rotate(t,i);
			}else{
				t=rotate(t,-i);
			}
			
			for(int j=0;j<4;j++){
				in[j+i*4]=t[j];
			}
		}//*/
		return in;
	}
	
	private static char[] keyScheduleCore(char[] in, int iter){
		in =rotate(in,1);
		char[] out =new char[4];
		for(int j=0;j<in.length;j++){
			out[j]=sbox[in[j]];
		}
		out[0]=(char) (out[0] ^ rcon[iter]);
		return out;
	}
	
	private static char[] expandKey(char[] key){
	    int keySize = 32;
	    char[] expandedKey = new char[240];
	    int currentSize = 0;
	    int rconIter = 1;
	    
	    char[] t = {0,0,0,0};

	    for(int i=0;i<keySize;i++){
	        expandedKey[i]=(key[i]);
	    }
	    currentSize += keySize;

	    while( currentSize < 240){
	        for(int i=0;i<4;i++){
	            t[i] = expandedKey[currentSize - 4 + i];
	        }
	        
	        if(currentSize % keySize == 0){
	            t = keyScheduleCore(t, rconIter);
	            rconIter += 1;
	        }
	        
	        if(currentSize % keySize == 16){
	            for(int i=0;i<4;i++){
	                t[i] = sbox[t[i]];
	            }
	        }
	        
	        for(int i=0;i<4;i++){
	            expandedKey[currentSize] =(char) ((expandedKey[currentSize - keySize]) ^ (t[i]));
	            currentSize += 1;
	        }
	    }        
	    return expandedKey;
	}
	
	public static char[] subBytes(char[] in){
		for(int i=0; i<in.length;i++){
			in[i] = sbox[in[i]];
		}//*/
		return in;
	}
	
	public static char[] subBytesInv(char[] in){
		for(int i=0; i<in.length;i++){
			in[i] = sboxInv[in[i]];
		}//*/
		return in;
	}
	
	public static char[] addRoundKey(char[] in, char[] roundKey){
		/*for(int i=0;i<in.length;i++){
			in[i]=(char) (in[i] ^ roundKey[i]);
		}//*/
		return in;
	}
	
	public static char galoisMult(char a, char b){
		char r=0;
		char hiBitSet=0;
		for(int i=0;i<8;i++){
			if ((b & 1) == 1){
	            r ^= a;
			}
	        hiBitSet = (char) (a & 0x80);
	        a <<= 1;
	        a &= 0xFF;
	        if(hiBitSet == 0x80){
	            a ^= 0x1b;
	        }
	        b >>= 1;
		}
		return r;
	}
	
	private static char[] mixColumn(char[] in){
		char[] out = new char[4];
	    out[0] = (char) (galoisMult(in[0],(char)2) ^ galoisMult(in[3],(char)1) ^ 
	                galoisMult(in[2],(char)1) ^ galoisMult(in[1],(char)3));
	    out[1] = (char) (galoisMult(in[1],(char)2) ^ galoisMult(in[0],(char)1) ^ 
	                galoisMult(in[3],(char)1) ^ galoisMult(in[2],(char)3));
	    out[2] = (char) (galoisMult(in[2],(char)2) ^ galoisMult(in[1],(char)1) ^ 
	                galoisMult(in[0],(char)1) ^ galoisMult(in[3],(char)3));
	    out[3] = (char) (galoisMult(in[3],(char)2) ^ galoisMult(in[2],(char)1) ^ 
	                galoisMult(in[1],(char)1) ^ galoisMult(in[0],(char)3));
		return out;
	}
	
	private static char[] mixColumnInv(char[] in){
		char[] out=new char[4];
	    out[0] = (char) (galoisMult(in[0],(char)14) ^ galoisMult(in[3],(char)9) ^ 
	                galoisMult(in[2],(char)13) ^ galoisMult(in[1],(char)11));
	    out[1] = (char) (galoisMult(in[1],(char)14) ^ galoisMult(in[0],(char)9) ^ 
	                galoisMult(in[3],(char)13) ^ galoisMult(in[2],(char)11));
	    out[2] = (char) (galoisMult(in[2],(char)14) ^ galoisMult(in[1],(char)9) ^ 
	                galoisMult(in[0],(char)13) ^ galoisMult(in[3],(char)11));
	    out[3] = (char) (galoisMult(in[3],(char)14) ^ galoisMult(in[2],(char)9) ^ 
	                galoisMult(in[1],(char)13) ^ galoisMult(in[0],(char)11));
		return out;
	}
	
	private static char[] mixColumns(char[] in){
		char[] out= new char[in.length];
		for(int i=0;i<4;i++){
			char[] col = new char[4];
			for(int j=0;j<4;j++){
				col[j]=in[j*4+i];
			}
			
			mixColumn(col);
			
			for(int j=0;j<4;j++){
				out[j*4+i]=col[j];
			}
		}
		return out;//*/
		/*return in;//*/
	}
	
	private static char[] mixColumnsInv(char[] in){
		char[] out= new char[in.length];
		for(int i=0;i<4;i++){
			char[] col = new char[4];
			for(int j=0;j<4;j++){
				col[j]=in[j*4+i];
			}
			
			mixColumnInv(col);
			
			for(int j=0;j<4;j++){
				out[j*4+i]=col[j];
			}
		}
		return out;//*/
		/*return in;//*/
	}
	
	private static char[] aesRound(char[] in, char[] roundKey){;
	    in=subBytes(in);
	    in=shiftRows(in, true);
	    in=mixColumns(in);
	    in=addRoundKey(in, roundKey);
	    return in;
	}
	
	private static char[] aesRoundInv(char[] in, char[] roundKey){
	    in=addRoundKey(in, roundKey);
	    in=mixColumnsInv(in);
	    in=shiftRows(in,false);
	    in=subBytesInv(in);
	    return in;
	}
	
	public static char[] createRoundKey(char[] expandKey, int n){
		char[] out=new char[16];
		for(int i=0;i<16;i++){
			out[i]=expandKey[n*16+i];
		}
		return out;
	}
	
	public static char[] passwordToKey(String passwd){
		MessageDigest md;
		try {
			md = MessageDigest.getInstance("SHA-256");
			md.update(passwd.getBytes("UTF-8"));
			byte[] bArr = md.digest();
			char[] out=new char[32];
			for(int i=0;i<bArr.length;i++){
				out[i]=(char) bArr[i];
			}
			return out;
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			char[] test={'a'};
			return test;
		}
	}
	
	private static char[] aesMain(char[] in, char[] expandKey){
		char[] roundKey = createRoundKey(expandKey, 0);
		char[] out = addRoundKey(in, roundKey);
		
		for(int i=1;i<14;i++){
			roundKey = createRoundKey(expandKey,i);
			out=aesRound(out,roundKey);
		}
		
		roundKey = createRoundKey(expandKey, 14);
		out=subBytes(out);
		out=shiftRows(out,true);
		out=addRoundKey(out, roundKey);
		return out;
	}
	
	private static char[] aesMainInv(char[] in, char[] expandKey){
		char[] roundKey = createRoundKey(expandKey, 14);
		char[] out = addRoundKey(in, roundKey);
		
		for(int i=13;i>0;i--){
			roundKey = createRoundKey(expandKey,i);
			out=aesRoundInv(out,roundKey);
		}
		
		roundKey = createRoundKey(expandKey, 0);
		out=subBytesInv(out);
		out=shiftRows(out,false);
		out=addRoundKey(out, roundKey);
		return out;
	}
	
	private static void printArr(char[] in){
		System.out.print("[");
		for(char c:in){
			System.out.print((int)c+",");
		}
		System.out.println("]");
	}

}
